# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['mkdir_if_needed', 'meta_to_img_path', 'meta_to_mask_path', 'fix_abangle', 'meta_to_df', 'draw_ellipse',
           'ellipse_to_bbox', 'ring_float_to_class_int']

# Cell
import cv2
import numpy as np
from pathlib import Path
import os
import pandas as pd

# Cell
def mkdir_if_needed(path:str):
    try:                # go ahead and try to make the the directory
        os.makedirs(path)
    except FileExistsError: pass
    except OSError as exception:
        if exception.errno != errno.EEXIST:  # ignore error if dir already exists
            raise

# Cell
def meta_to_img_path(
    meta_file:str, # filename of .csv file with annotations
    img_bank='images/',         # alternate location of image files, if not in same dir as meta file
    ):
    '''Suggest the image file that corresponds with an annotation CSV file'''
    meta_file, img_dir = Path(meta_file), Path(os.path.expanduser(img_bank))
    img_file = meta_file.with_suffix('.png')  # check same directory as meta first
    if os.path.exists(img_file): return img_file
    return img_dir / Path(img_file.name)  # return from image storage directory

# Cell
def meta_to_mask_path(
    meta_file:str, # filename of .csv file with annotations
    mask_dir='masks/',  # output directory; assumed to exist
    ):
    "provides name for segmentation mask file"
    csv_path = Path(meta_file)
    return Path(mask_dir + csv_path.stem+'_P.png')  # _P because that's what CAMVID dataset does

# Cell
def fix_abangle(
    a:float, # semimajor axis
    b:float, # semiminor axis
    angle:float,  # orientation angle in degrees
    ):
    "Makes sure semimajor axis > semiminor axis, and angles are consistent"
    if b > a:
        a, b, angle = b, a, angle+90
    if angle < 0: angle += 180
    elif angle >= 180: angle -= 180
    return a, b, angle

# Cell
def meta_to_df(
    meta_file,  # csv file of ellipse data for an image
    ):
    "Reads in an espiownage/SPNet CSV file of ellipse data and returns a Pandas DataFrame"
    col_names = ['cx', 'cy', 'a', 'b', 'angle', 'rings']
    df = pd.read_csv(meta_file, header=None, names=col_names)
    df.drop_duplicates(inplace=True)  # sometimes the data from Zooniverse has duplicate rows
    for index, row in df.iterrows() : # fixup stuff
        [cx, cy, a, b, angle] = [int(round(x)) for x in [row['cx'], row['cy'], row['a'], row['b'], row['angle']]]
        a, b, angle = fix_abangle(a,b,angle)
        row['cx'], row['cy'], row['a'], row['b'], row['angle'] = cx, cy, a, b, angle
    return df

# Cell
def draw_ellipse(
    img,         # a cv2 image, *not* a PIL image (similar for grayscale but not RGB)
    center:tuple,      # (cx, cy) tuple
    axes:tuple,        # (a,b) semimajor & minor axes
    angle:float,       # orientation angle in degrees
    color=(0),   # color to draw. tuple or int
    thickness=2, # thickness ofthe lines we draw
    filled=False,  # whether to draw the ellipse as filled or not
    lineType=cv2.LINE_8,  # as opposed to LINE_AA, typically we DON'T want antialiasing for this app
    startAngle=0, endAngle=360, # arc-angles. should stay at 0 & 360 for full ellipses.
    shift=0, #10,      # shift is for sub-pixel resolution and AA figures. don't need it.
    ):
    """"Draws an ellipse into image.    """
    center = [int(round(x* 2**shift)) for x in center]
    axes = [int(round(x* 2**shift)) for x in axes]
    if filled: lineType, thickness = cv2.FILLED, -1
    ellipse = cv2.ellipse(
        img, center, axes, -angle,   # -angle because the web interface is "upside down"
        startAngle, endAngle, color,
        thickness, lineType, shift)
    return ellipse

# Cell
def ellipse_to_bbox(
    x:float, # x-coordinate of center of ellipse
    y:float, # y-coordinate of center of ellipse
    a:float, # semimajor axis
    b:float, # semiminor axis
    angle_deg:float,  # orientation angle in degrees
    coco=False, # COCO style bbox has last 2 nums as width & height of bbox
    clip=True, # clip values at max values of image width & height
    width=512, height=384,
    tol=1e-10, # numerical precision below which start rounding things
    ):
    "Get bounding box of ellipse, cf. https://gist.github.com/smidm/b398312a13f60c24449a2c7533877dc0"
    major, minor = 2*a, 2*b
    if 0==major: major = tol
    if 0==angle_deg: angle_deg = tol    # slight fudge to avoid division by zero
    t = np.arctan(-minor / 2 * np.tan(np.radians(angle_deg)) / (major / 2))
    [max_x, min_x] = sorted([x + major / 2 * np.cos(t) * np.cos(np.radians(angle_deg)) -
                      minor / 2 * np.sin(t) * np.sin(np.radians(angle_deg)) for t in (t, t + np.pi)],reverse=True)
    t = np.arctan(minor / 2 * 1. / np.tan(np.radians(angle_deg)) / (major / 2))
    [max_y, min_y] = sorted([y + minor / 2 * np.sin(t) * np.cos(np.radians(angle_deg)) +
                      major / 2 * np.cos(t) * np.sin(np.radians(angle_deg)) for t in (t, t + np.pi)],reverse=True)
    if clip:
      min_x = np.clip(min_x, 0, width)
      max_x = np.clip(max_x, 0, width)
      min_y = np.clip(min_y, 0, height)
      max_y = np.clip(max_y, 0, height)
    if coco: return [round(x, 2) for x in [min_x, min_y, max_x-min_x, max_y-min_y]] # coco is a list, floats are ok
    return int(min_x), int(min_y), int(max_x), int(max_y)

# Cell
def ring_float_to_class_int(rings:float, step=0.1):
    """Ring value rounded to classifier value; rounded to nearest step size"""
    return round(rings/step)
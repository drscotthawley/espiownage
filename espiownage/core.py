# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['mkdir_if_needed', 'meta_to_img_path', 'meta_to_mask_path', 'fix_abangle', 'draw_ellipse']

# Cell
import cv2
import numpy as np
from pathlib import Path
import os

# Cell
def mkdir_if_needed(path):
    try:                # go ahead and try to make the the directory
        os.makedirs(path)
    except FileExistsError: pass
    except OSError as exception:
        if exception.errno != errno.EEXIST:  # ignore error if dir already exists
            raise

# Cell
def meta_to_img_path(meta_file, # filename of .csv file with annotations
    img_bank='images/',         # alternate location of image files, if not in same dir as meta file
    ):
    '''Suggest the image file that corresponds with an annotation CSV file'''
    meta_file, img_dir = Path(meta_file), Path(os.path.expanduser(img_bank))
    img_file = meta_file.with_suffix('.png')  # check same directory as meta first
    if os.path.exists(img_file): return img_file
    return img_dir / Path(img_file.name)  # return from image storage directory

# Cell
def meta_to_mask_path(
    meta_file, # filename of .csv file with annotations
    mask_dir='masks/',  # output directory; assumed to exist
    ):
    "provides name for segmentation mask file"
    csv_path = Path(meta_file)
    return Path(mask_dir + csv_path.stem+'_P.png')  # _P because that's what CAMVID dataset does

# Cell
def fix_abangle(a,b,angle):
    "Makes sure semimajor axis > semiminor axis, and angles are consistent"
    if b > a:
        a, b, angle = b, a, angle+90
    if angle < 0: angle += 180
    elif angle >= 180: angle -= 180
    return a, b, angle

# Cell
def draw_ellipse(
    img,     # a cv2 image, not a PIL image?
    center, axes, angle,
    startAngle=0, endAngle=360, color=(0) ,
    thickness=2, lineType=cv2.LINE_AA, shift=10, filled=False):
    """"Draws an ellipse into image.
    startAngle & endAngle should are arc-angles. They should stay at 0 & 360 for full ellipses.
    """
    center = [int(round(x* 2**shift)) for x in center]
    axes = [int(round(x* 2**shift)) for x in axes]
    if filled: lineType,thickness = cv2.FILLED, -1
    ellipse = cv2.ellipse(
        img, center, axes, -angle,   # -angle because the web interface is "upside down"
        startAngle, endAngle, color,
        thickness, lineType, shift)
    return ellipse
# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['mkdir_if_needed', 'meta_to_img_path', 'meta_to_mask_path', 'fix_abangle', 'draw_ellipse', 'ellipse_to_bbox']

# Cell
import cv2
import numpy as np
from pathlib import Path
import os
import matplotlib.pyplot as plt

# Cell
def mkdir_if_needed(path:str):
    try:                # go ahead and try to make the the directory
        os.makedirs(path)
    except FileExistsError: pass
    except OSError as exception:
        if exception.errno != errno.EEXIST:  # ignore error if dir already exists
            raise

# Cell
def meta_to_img_path(
    meta_file:str, # filename of .csv file with annotations
    img_bank='images/',         # alternate location of image files, if not in same dir as meta file
    ):
    '''Suggest the image file that corresponds with an annotation CSV file'''
    meta_file, img_dir = Path(meta_file), Path(os.path.expanduser(img_bank))
    img_file = meta_file.with_suffix('.png')  # check same directory as meta first
    if os.path.exists(img_file): return img_file
    return img_dir / Path(img_file.name)  # return from image storage directory

# Cell
def meta_to_mask_path(
    meta_file:str, # filename of .csv file with annotations
    mask_dir='masks/',  # output directory; assumed to exist
    ):
    "provides name for segmentation mask file"
    csv_path = Path(meta_file)
    return Path(mask_dir + csv_path.stem+'_P.png')  # _P because that's what CAMVID dataset does

# Cell
def fix_abangle(a,b,angle):
    "Makes sure semimajor axis > semiminor axis, and angles are consistent"
    if b > a:
        a, b, angle = b, a, angle+90
    if angle < 0: angle += 180
    elif angle >= 180: angle -= 180
    return a, b, angle

# Cell
def draw_ellipse(
    img,         # a cv2 image, *not* a PIL image (similar for grayscale but not RGB)
    center:tuple,      # (cx, cy) tuple
    axes:tuple,        # (a,b) semimajor & minor axes
    angle,       # orientation angle in degrees
    color=(0),   # color to draw. tuple or int
    thickness=2, # thickness ofthe lines we draw
    filled=False,  # whether to draw the ellipse as filled or not
    lineType=cv2.LINE_8,  # as opposed to LINE_AA, typically we DON'T want antialiasing for this app
    startAngle=0, endAngle=360, # arc-angles. should stay at 0 & 360 for full ellipses.
    shift=0, #10,      # shift is for sub-pixel resolution and AA figures. don't need it.
    ):
    """"Draws an ellipse into image.    """
    center = [int(round(x* 2**shift)) for x in center]
    axes = [int(round(x* 2**shift)) for x in axes]
    if filled: lineType, thickness = cv2.FILLED, -1
    ellipse = cv2.ellipse(
        img, center, axes, -angle,   # -angle because the web interface is "upside down"
        startAngle, endAngle, color,
        thickness, lineType, shift)
    return ellipse

# Cell
def ellipse_to_bbox(x, y, a, b, angle_deg,
    clip=True, width=512, height=384):  # cx, cy, a, b, angle
    "Get bounding box of ellipse, cf. https://gist.github.com/smidm/b398312a13f60c24449a2c7533877dc0"
    major, minor = 2*a, 2*b
    t = np.arctan(-minor / 2 * np.tan(np.radians(angle_deg)) / (major / 2))
    [max_x, min_x] = sorted([x + major / 2 * np.cos(t) * np.cos(np.radians(angle_deg)) -
                      minor / 2 * np.sin(t) * np.sin(np.radians(angle_deg)) for t in (t, t + np.pi)],reverse=True)
    t = np.arctan(minor / 2 * 1. / np.tan(np.radians(angle_deg)) / (major / 2))
    [max_y, min_y] = sorted([y + minor / 2 * np.sin(t) * np.cos(np.radians(angle_deg)) +
                      major / 2 * np.cos(t) * np.sin(np.radians(angle_deg)) for t in (t, t + np.pi)],reverse=True)
    if clip:
      min_x = np.clip(min_x, 0, width)
      max_x = np.clip(max_x, 0, width)
      min_y = np.clip(min_y, 0, height)
      max_y = np.clip(max_y, 0, height)
    return int(min_x), int(min_y), int(max_x), int(max_y)